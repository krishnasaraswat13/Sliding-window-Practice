class Solution {
    public int subarraySum(int[] nums, int k) {
        HashMap<Integer, Integer> subNum = new HashMap<>();
        subNum.put(0, 1);
        int total = 0, count = 0;

        for (int n : nums) {
            total += n;

            if (subNum.containsKey(total - k)) {
                count += subNum.get(total - k);
            }

            subNum.put(total, subNum.getOrDefault(total, 0) + 1);
        }

        return count;  
    }
}
//this is for positive and negative both
//if only positive then sliding window can be used as->
class Solution {
    public int subarraySum(int[] nums, int k) {
        int i=0;
        int j=0;
        int sum=0;
        int cnt=0;
        while(j<nums.length){
            sum+=nums[j];
            if(sum<k){
                j++;
            }
            else if(sum==k){
                cnt++;
                j++;
            }
            else if(sum>k){
                while(sum>k){
                    sum-=nums[i];
                    i++;
                }
                if(sum==k){
                    cnt++;
                }
                j++;
            }
        }
        return cnt;
    }
}
//or
 class Solution {
    int SubarrayWithSumLessThanGoal(int nums[], int goal){
        int l=0,r=0,n=nums.length;
        int sum = 0,cnt = 0;
        if(goal < 0) return 0;
        while(r<n){
            sum += nums[r];
            while(sum > goal){
                sum -= nums[l];
                l++;
            } 
            cnt += (r - l + 1); 
            r++;
        }
        return cnt;
    }
    public int numSubarraysWithSum(int[] nums, int goal) {
        int a = SubarrayWithSumLessThanGoal(nums, goal);
        int b = SubarrayWithSumLessThanGoal(nums, goal - 1);

        return a - b;
    }
}